{"version":3,"sources":["useInput.ts","App.tsx","index.tsx"],"names":["useKeyDown","targetKeyCode","useState","keyPressed","setKeyPressed","keyDown","useCallback","keyCode","keyUp","useEffect","window","addEventListener","removeEventListener","ballColors","getBallColor","ballId","length","useStore","create","set","get","player","orientation","Quaternion","color","Math","floor","random","balls","List","nextBallId","bricks","Map","nextBrickId","outlineSelection","Set","actions","addBall","state","ball","translation","Vector3","direction","position","applyQuaternion","velocity","multiplyScalar","createBallFromPlayer","push","slice","removeBrick","brickId","delete","addRandomBrick","addBrick","brickGap","maxBricks","PI","positionX","positionY","getRandomBrickPosition","brick","orbitOffset","addDefaultBricks","samples","radius","points","offset","increment","sqrt","i","y","distance","pow","phi","x","cos","z","sin","generateFibonacciSphere","forEach","updateBrick","changes","update","value","movePlayer","delta","leftPressed","rightPressed","upPressed","downPressed","touchPosition","verticalAngle","innerHeight","innerWidth","getAngleFromInput","horizontalAngle","verticalAxis","verticalRotation","setFromAxisAngle","horizontalAxis","horizontalRotation","clone","multiply","addOutlineSelection","mesh","add","removeOutlineSelection","remove","resetGame","PlayerGroup","KEY_LEFT","KEY_RIGHT","KEY_UP","KEY_DOWN","touchDown","setTouchDown","setTouchPosition","handleMouseDown","event","clientX","clientY","handleMouseMove","handleTouchStart","touches","handleTouchMove","handleTouchEnd","undefined","useTouch","padGroup","useRef","camera","padSize","useBox","args","mass","toArray","rotation","type","onCollide","collide","ref","api","e","callback","keyPress","useKeyPress","KEY_SPACE","useFrame","Euler","setFromQuaternion","copy","current","RoundedBox","onClick","receiveShadow","attach","PerspectiveCamera","makeDefault","BallGroup","props","map","BallMesh","useSphere","scale","castShadow","BrickGroup","valueSeq","BrickMesh","playerColor","useMemo","eye","target","up","lookAt","Matrix4","setFromRotationMatrix","brickSize","Effects","outlineSelectionArray","filter","v","gPressed","KEY_G","fallback","multisampling","autoClear","active","ratio","delay","Vector2","selection","edgeStrength","pulseSpeed","visibleEdgeColor","hiddenEdgeColor","blur","xRay","width","height","Stars","depth","count","factor","saturation","fade","eskil","darkness","ViewportResize","useThree","gl","viewport","targetSize","aspect","getDrawingBufferSize","equals","setDrawingBufferSize","App","style","backgroundColor","shadows","Stats","showPanel","className","AdaptiveDpr","pixelated","gravity","defaultContactMaterial","friction","restitution","shadow-mapSize-width","shadow-mapSize-height","softShadows","frustum","size","near","rings","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"gUAEO,SAASA,EAAWC,GACzB,MAAoCC,oBAAS,GAA7C,mBAAOC,EAAP,KAAmBC,EAAnB,KAEMC,EAAUC,uBACd,YAAiB,EAAdC,UACeN,GACdG,GAAc,KAGlB,CAACH,IAGGO,EAAQF,uBACZ,YAAiB,EAAdC,UACeN,GACdG,GAAc,KAGlB,CAACH,IAYH,OATAQ,qBAAU,WAGR,OAFAC,OAAOC,iBAAiB,UAAWN,GACnCK,OAAOC,iBAAiB,QAASH,GAC1B,WACLE,OAAOE,oBAAoB,UAAWP,GACtCK,OAAOE,oBAAoB,QAASJ,MAErC,CAACH,EAASG,IAENL,E,YC6BHU,EAAa,CACjB,mBACA,oBACA,oBACA,oBACA,qBACA,oBACA,qBAGF,SAASC,EAAaC,GACpB,OAAOF,EAAWE,EAASF,EAAWG,QAUxC,IAyEMC,EAAWC,aAAiB,SAACC,EAAKC,GAAN,MAAe,CAC/CC,OApGkC,CAClCC,YAAa,IAAIC,aACjBC,MAAOV,EAAaW,KAAKC,MAAMD,KAAKE,SAAWd,EAAWG,UAmG1DY,MAAOC,cACPC,WAAY,EACZC,OAAQC,cACRC,YAAa,EACbC,iBAAkBC,cAClBC,QAAS,CACPC,QAAS,kBACPlB,GAAI,SAACmB,GACH,IAAMC,EAnFe,SAACxB,EAAgBM,GAC5C,IAAMmB,EAAc,IAAIC,UAAQ,EAAG,EAAG,GAChCC,EAAY,IAAID,UAAQ,EAAG,GAAI,GAOrC,MAAO,CACL1B,SACA4B,SAPeH,EAAYI,gBAAgBvB,EAAOC,aAQlDuB,SAPeH,EACdE,gBAAgBvB,EAAOC,aACvBwB,eAAe,GAMhBtB,MAAOH,EAAOG,OAsEGuB,CAAqBT,EAAMR,WAAYQ,EAAMjB,QAC1D,MAAO,CACLO,MAAOU,EAAMV,MAAMoB,KAAKT,GAAMU,OAAO,GACrCnB,WAAYQ,EAAMR,WAAa,OAGrCoB,YAAa,SAACC,GAAD,OACXhC,GAAI,SAACmB,GAAD,MAAY,CAAEP,OAAQO,EAAMP,OAAOqB,OAAOD,QAChDE,eAAgB,YAIdC,EADIlC,IADFgB,QAAWkB,UA/DY,WAC7B,IACMC,EAAW,GACXC,EAAY/B,KAAKC,MAAO,EAAID,KAAKgC,IAFpB,GAEwCF,IACrDG,EAAYjC,KAAKC,MAAMD,KAAKE,SAAW6B,GACvCG,EAAYlC,KAAKC,MAAMD,KAAKE,SAAW6B,GAE7C,OAAO,IAAIf,UACTiB,GAPiB,GAOSH,GAAYA,GACtCI,GARiB,GAQSJ,GAAYA,GACtC,KAuDWK,KAEXN,SAAU,SAACX,GAAD,OACRxB,GAAI,SAACmB,GACH,IA3Eaa,EA2EPU,EA3EyD,CACrEV,QADmBA,EA2Eab,EAAML,YAzEtC6B,YAyEmDnB,EAxEnDnB,MAAOV,EAAaqC,IAyEd,MAAO,CACLpB,OAAQO,EAAMP,OAAOZ,IAAI0C,EAAMV,QAASU,GACxC5B,YAAaK,EAAML,YAAc,OAGvC8B,iBAAkB,WAChB,IACaT,EACTlC,IADFgB,QAAWkB,SAEbnC,GAAI,SAACmB,IAkEX,WAQE,IAPA,IAAM0B,EAAU,GACVC,EAAS,IAETC,EAAS,GACTC,EAAS,EAAIH,EACbI,EAAY3C,KAAKgC,IAAM,EAAIhC,KAAK4C,KAAK,IAElCC,EAAI,EAAGA,EAAIN,EAASM,IAAK,CAChC,IAAMC,EAAID,EAAIH,EAAS,EAAIA,EAAS,EAC9BK,EAAW/C,KAAK4C,KAAK,EAAI5C,KAAKgD,IAAIF,EAAG,IACrCG,GAAQJ,EAAI,GAAKN,EAAWI,EAC5BO,EAAIlD,KAAKmD,IAAIF,GAAOF,EACpBK,EAAIpD,KAAKqD,IAAIJ,GAAOF,EAC1BN,EAAOlB,KAAK,IAAIP,UAAQkC,EAAIV,EAAQM,EAAIN,EAAQY,EAAIZ,IAGtD,OAAOC,GAlFca,GACRC,QAAQ1B,OAGnB2B,YAAa,SAAC9B,EAAiB+B,GAAlB,OACX/D,GAAI,SAACmB,GAAD,MAAY,CACdP,OAAQO,EAAMP,OAAOoD,OAAOhC,GAAS,SAACiC,GAAD,mBAAC,eACjCA,GACAF,WAGTG,WAAY,SACVC,EACAC,EACAC,EACAC,EACAC,EACAC,GANU,OAQVxE,GAAI,SAACmB,GACH,MAiER,SACEiD,EACAC,EACAC,EACAC,EACAC,GAEA,GAAIA,EAAe,CACjB,IAAMC,EACkE,IAApElF,OAAOmF,YAAcF,EAAcpB,GAAK7D,OAAOmF,YAAc,IAEjE,MAAO,CAD+D,GAA7CF,EAAchB,EAAIjE,OAAOoF,WAAa,IACtCF,GAI3B,MAAO,CADiBL,GAAe,EAAIC,EAAe,EAAI,EADxCE,GAAe,EAAID,EAAY,EAAI,GA9EVM,CACvCR,EACAC,EACAC,EACAC,EACAC,GALF,mBAAOK,EAAP,KAAwBJ,EAAxB,KAOMK,EAAe,IAAIxD,WAAS,EAAG,EAAG,GAClCyD,GAAmB,IAAI3E,cAAa4E,iBACxCF,EACAL,EAAgBN,GAEZc,EAAiB,IAAI3D,UAAQ,EAAG,EAAG,GACnC4D,GAAqB,IAAI9E,cAAa4E,iBAC1CC,EACAJ,EAAkBV,GAGdhE,EAAcgB,EAAMjB,OAAOC,YAC9BgF,QACAC,SAASL,GACTK,SAASF,GAEZ,MAAO,CACLhF,OAAO,2BACFiB,EAAMjB,QADL,IAEJC,qBAIRkF,oBAAqB,SAACC,GAAD,OACnBtF,GAAI,SAACmB,GAAD,MAAY,CAAEJ,iBAAkBI,EAAMJ,iBAAiBwE,IAAID,QACjEE,uBAAwB,SAACF,GAAD,OACtBtF,GAAI,SAACmB,GAAD,MAAY,CACdJ,iBAAkBI,EAAMJ,iBAAiB0E,OAAOH,QAEpDI,UAAW,YAIT9C,EADI3C,IADFgB,QAAW2B,0BAqDnB,SAAS+C,IACP,IAAMN,EAAsBvF,GAC1B,SAACqB,GAAD,OAAWA,EAAMF,QAAQoE,uBAErBG,EAAyB1F,GAC7B,SAACqB,GAAD,OAAWA,EAAMF,QAAQuE,0BAErBpB,EAAcvF,EAAW+G,KACzBvB,EAAexF,EAAWgH,KAC1BvB,EAAYzF,EAAWiH,KACvBvB,EAAc1F,EAAWkH,KACzBvB,EDnQD,WACL,MAAkCzF,oBAAkB,GAApD,mBAAOiH,EAAP,KAAkBC,EAAlB,KACA,EAA0ClH,qBAA1C,mBAAOyF,EAAP,KAAsB0B,EAAtB,KAEMC,EAAkBhH,uBAAY,SAACiH,GACnCF,EAAiB,CAAE1C,EAAG4C,EAAMC,QAASjD,EAAGgD,EAAME,UAC9CL,GAAa,KACZ,CAACC,EAAkBD,IAEhBM,EAAkBpH,uBAAY,SAACiH,GAC/BJ,GAAWE,EAAiB,CAAE1C,EAAG4C,EAAMC,QAASjD,EAAGgD,EAAME,YAC5D,CAACJ,EAAkBF,IAEhBQ,EAAmBrH,uBAAY,SAACiH,GACpCF,EAAiB,CAAE1C,EAAG4C,EAAMK,QAAQ,GAAGJ,QAASjD,EAAGgD,EAAMK,QAAQ,GAAGH,UACpEL,GAAa,KACZ,CAACC,EAAkBD,IAEhBS,EAAkBvH,uBAAY,SAACiH,GAC/BJ,GAAWE,EAAiB,CAAE1C,EAAG4C,EAAMK,QAAQ,GAAGJ,QAASjD,EAAGgD,EAAMK,QAAQ,GAAGH,YAClF,CAACJ,EAAkBF,IAEhBW,EAAiBxH,uBAAY,WACjC+G,OAAiBU,GACjBX,GAAa,KACZ,CAACC,EAAkBD,IAmBtB,OAjBA3G,qBAAU,WAOR,OANAC,OAAOC,iBAAiB,aAAcgH,GACtCjH,OAAOC,iBAAiB,YAAakH,GACrCnH,OAAOC,iBAAiB,WAAYmH,GACpCpH,OAAOC,iBAAiB,YAAa2G,GACrC5G,OAAOC,iBAAiB,YAAa+G,GACrChH,OAAOC,iBAAiB,UAAWmH,GAC5B,WACLpH,OAAOE,oBAAoB,aAAc+G,GACzCjH,OAAOE,oBAAoB,YAAaiH,GACxCnH,OAAOE,oBAAoB,WAAYkH,GACvCpH,OAAOE,oBAAoB,YAAa0G,GACxC5G,OAAOE,oBAAoB,YAAa8G,GACxChH,OAAOE,oBAAoB,UAAWkH,MAEvC,CAACH,EAAkBE,EAAiBC,EAAgBR,EAAiBI,IAEjE/B,ECuNeqC,GAChBC,EAAWC,iBAAc,MACzBC,EAASD,iBAAe,MACxB7G,EAASJ,GAAS,SAACqB,GAAD,OAAWA,EAAMjB,UACnCgE,EAAapE,GAAS,SAACqB,GAAD,OAAWA,EAAMF,QAAQiD,cAC/ChD,EAAUpB,GAAS,SAACqB,GAAD,OAAWA,EAAMF,QAAQC,WAC5C+F,EAAoC,CAAC,EAAG,GAAK,IAC7C5F,EAAc,IAAIC,UAAQ,EAAG,EAAG,GAEtC,EAAmB4F,aAAO,iBAAO,CAC/BC,KAAMF,EACNG,KAAM,EACN5F,SAAUH,EAAYgG,UACtBC,SAAU,CAAChH,KAAKgC,GAAI,EAAG,GACvBiF,KAAM,SACNC,UAAWC,MANb,mBAAOC,EAAP,KAAYC,EAAZ,KASMF,EAAUtI,uBAAY,SAACyI,MAAiB,IAgC9C,ODzUK,SAAqB9I,EAAuB+I,GACjD,IAAMC,EAAW3I,uBACf,YAAiB,EAAdC,UACeN,GACd+I,MAGJ,CAAC/I,EAAe+I,IAGlBvI,qBAAU,WAER,OADAC,OAAOC,iBAAiB,WAAYsI,GAC7B,WACLvI,OAAOE,oBAAoB,WAAYqI,MAExC,CAACA,IC4RJC,CAAYC,IAAW9G,GAEvB+G,aAAS,SAAC9G,EAAOgD,GACfD,EACEC,EACAC,EACAC,EACAC,EACAC,EACAC,GAGF,IAAM8C,GAAW,IAAIY,SAAQC,kBAAkBjI,EAAOC,aAChDqB,EAAWH,EAAY8D,QAAQ1D,gBAAgBvB,EAAOC,aAE5DwH,EAAIL,SAASc,KAAKd,GAClBK,EAAInG,SAAS4G,KAAK5G,MAGpBlC,qBAAU,WACR,IAAMgG,EAAOoC,EAAIW,QAEjB,OADA/C,EAAK9F,iBAAiB,UAAWiI,GAC1B,kBAAMnC,EAAK7F,oBAAoB,UAAWgI,MAChD,CAACC,EAAKD,IAETnI,qBAAU,WAER,OADA+F,EAAoBqC,GACb,kBAAMlC,EAAuBkC,MACnC,CAACA,EAAKrC,EAAqBG,IAG5B,uBAAOkC,IAAKZ,EAAUtF,SAAU,CAAC,EAAG,EAAG,GAAvC,SACE,eAAC8G,EAAA,EAAD,CACEnB,KAAMF,EACNnE,OAAQ,IACR4E,IAAKA,EACLa,QAASrH,EACTsH,eAAa,EALf,UAOE,kCAAkBC,OAAO,WAAWpI,MAAM,YAC1C,cAACqI,EAAA,EAAD,CACEC,aAAW,EACXjB,IAAKV,EACLxF,SAAU,CAAC,EAAG,EAAG,GACjB8F,SAAU,EAAEhH,KAAKgC,GAAK,GAAI,EAAG,UAOvC,SAASsG,EAAUC,GACjB,IAAMpI,EAAQX,GAAS,SAACqB,GAAD,OAAWA,EAAMV,SAExC,OACE,iDAAWoI,GAAX,aACGpI,EAAMqI,KAAI,SAAC1H,GAAD,OACT,cAAC2H,EAAD,CAA4B3H,KAAMA,GAAnBA,EAAKxB,cAM5B,SAASmJ,EAAT,GAA6C,IAAzB3H,EAAwB,EAAxBA,KACZiE,EAAsBvF,GAC1B,SAACqB,GAAD,OAAWA,EAAMF,QAAQoE,uBAErBG,EAAyB1F,GAC7B,SAACqB,GAAD,OAAWA,EAAMF,QAAQuE,0BAI3B,EAAcwD,aAAU,iBAAO,CAC7B7B,KAHiB,GAIjBC,KAAM,EACN5F,SAAUJ,EAAKI,SAAS6F,UACxB3F,SAAUN,EAAKM,SAAS2F,cAJnBK,EAAP,oBAYA,OALApI,qBAAU,WAER,OADA+F,EAAoBqC,GACb,kBAAMlC,EAAuBkC,MACnC,CAACA,EAAKrC,EAAqBG,IAG5B,uBAAMkC,IAAKA,EAAKuB,MAfC,GAekBC,YAAU,EAA7C,UACE,gCAAgB/B,KAAM,CAAC,EAAG,GAAI,MAC9B,kCAAkBsB,OAAO,WAAWpI,MAAOe,EAAKf,WAKtD,SAAS8I,IACP,IAAMvI,EAASd,GAAS,SAACqB,GAAD,OAAWA,EAAMP,UAEzC,OACE,gCACGA,EAAOwI,WAAWN,KAAI,SAACpG,GAAD,OACrB,cAAC2G,EAAD,CAA+B3G,MAAOA,GAAtBA,EAAMV,cAM9B,SAASqH,EAAT,GAAiD,IAA5B3G,EAA2B,EAA3BA,MACb4G,EAAcxJ,GAAS,SAACqB,GAAD,OAAWA,EAAMjB,OAAOG,SAC/CyD,EAAchE,GAAS,SAACqB,GAAD,OAAWA,EAAMF,QAAQ6C,eAChDuB,EAAsBvF,GAC1B,SAACqB,GAAD,OAAWA,EAAMF,QAAQoE,uBAErBG,EAAyB1F,GAC7B,SAACqB,GAAD,OAAWA,EAAMF,QAAQuE,0BAE3B,EAA6B+D,mBAC3B,kBAzJJ,SAAgBC,EAAcC,GAC5B,IAAMC,EAAK,IAAIpI,UAAQ,EAAG,EAAG,GACvBqI,GAAS,IAAIC,WAAUD,OAAOH,EAAKC,EAAQC,GAGjD,MAAO,EAFU,IAAIxB,SAAQ2B,sBAAsBF,GAEjCH,GAoJVG,CAAOjH,EAAMC,YAAa,IAAIrB,aACpC,CAACoB,IAFH,mBAAO4E,EAAP,KAAiB9F,EAAjB,KAIMsI,EAAsC,CAAC,GAAK,GAAK,IACvD,EAAc5C,aACZ,iBAAO,CACLC,KAAM2C,EACN1C,KAAM,EACN5F,SAAUA,EAAS6F,UACnBC,SAAUA,EAASD,UACnBE,KAAM,SACNC,UAAWC,UAEbb,EACA,CAACU,EAAU9F,IAVNkG,EAAP,oBAaMD,EAAUtI,uBACd,SAACyI,GACC9D,EAAYpB,EAAMV,QAAS,CAAE3B,MAAOiJ,MAEtC,CAACxF,EAAapB,EAAO4G,IAQvB,OALAhK,qBAAU,WAER,OADA+F,EAAoBqC,GACb,kBAAMlC,EAAuBkC,MACnC,CAACA,EAAKrC,EAAqBG,IAG5B,cAAC8C,EAAA,EAAD,CACEnB,KAAM2C,EACNhH,OAAQ,IACR4E,IAAKA,EACLc,eAAa,EAJf,SAME,kCAAkBC,OAAO,WAAWpI,MAAOqC,EAAMrC,UAKvD,SAAS0J,IACP,IAAMhJ,EAAmBjB,GAAS,SAACqB,GAAD,OAAWA,EAAMJ,oBAC7CiJ,EAAwBT,mBAC5B,kBACExI,EACGsG,UACA4C,QACC,SAACC,GAAD,YACgBtD,IAAdsD,EAAE7B,aAEV,CAACtH,IAEGoJ,EAAWtL,EAAWuL,KAE5B,OACE,cAAC,WAAD,CAAUC,SAAU,KAApB,SACE,eAAC,IAAD,CAAgBC,cAAe,EAAGC,WAAW,EAA7C,UACGJ,EACC,cAAC,IAAD,CACEK,QAAQ,EACRC,MAAO,IACPC,MAAO,IAAIC,UAAQ,EAAG,KAGxB,cAAC,IAAD,IAEF,cAAC,IAAD,CACEC,UAAWZ,EACXa,aAAc,GACdC,WAAY,EACZC,iBAAkB,SAClBC,gBAAiB,QACjBC,MAAM,EACNC,MAAM,EACNC,MAAO,KACPC,OAAQ,OAEV,cAACC,EAAA,EAAD,CACEvI,OAAQ,IACRwI,MAAO,GACPC,MAAO,IACPC,OAAQ,EACRC,WAAY,EACZC,MAAI,IAEN,cAAC,IAAD,CAAUC,OAAO,EAAO3I,OAAQ,GAAK4I,SAAU,WAYvD,SAASC,IACP,MAAyBC,cAAjBC,EAAR,EAAQA,GAAIC,EAAZ,EAAYA,SACNC,EAAa,IAAItB,UAAQ,KAAM,KAAOqB,EAASE,QASrD,OAPAjE,aAAS,WACM8D,EAAGI,qBAAqB,IAAIxB,WAC/ByB,OAAOH,IACfF,EAAGM,qBAAqBJ,EAAWzI,EAAGyI,EAAW7I,EAAG,MAIjD,KAWM,SAASkJ,IACtB,IAAM5G,EAAY5F,GAAS,SAACqB,GAAD,OAAWA,EAAMF,QAAQyE,aAGpD,OAFApG,oBAAUoG,EAAW,CAACA,IAGpB,eAAC,IAAD,CAAQ6G,MAAO,CAAEC,gBAAiB,WAAaC,SAAO,EAAtD,UACE,cAACZ,EAAD,IACA,cAACa,EAAA,EAAD,CACEC,UAAW,EACXC,UAAU,UAEZ,cAACC,EAAA,EAAD,CAAaC,WAAS,IACtB,eAAC,IAAD,CACEC,QAAS,CAAC,EAAG,EAAG,GAChBC,uBAAwB,CACtBC,SAAU,EACVC,YAAa,KAJjB,UAOE,4BACE1L,SAAU,CAAC,GAAI,GAAI,IACnB0H,YAAU,EACViE,uBAAsB,IACtBC,wBAAuB,MAEzB,cAACxE,EAAD,IACA,cAACO,EAAD,IACA,cAACxD,EAAD,OAEF,cAACoE,EAAD,OArCNsD,YAAY,CACVC,QAAS,KACTC,KAAM,KACNC,KAAM,IACN3K,QAAS,GACT4K,MAAO,KC/iBTC,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.970f1ffa.chunk.js","sourcesContent":["import { useCallback, useEffect, useState } from \"react\";\n\nexport function useKeyDown(targetKeyCode: number): boolean {\n  const [keyPressed, setKeyPressed] = useState(false);\n\n  const keyDown = useCallback(\n    ({ keyCode }) => {\n      if (keyCode === targetKeyCode) {\n        setKeyPressed(true);\n      }\n    },\n    [targetKeyCode]\n  );\n\n  const keyUp = useCallback(\n    ({ keyCode }) => {\n      if (keyCode === targetKeyCode) {\n        setKeyPressed(false);\n      }\n    },\n    [targetKeyCode]\n  );\n\n  useEffect(() => {\n    window.addEventListener(\"keydown\", keyDown);\n    window.addEventListener(\"keyup\", keyUp);\n    return () => {\n      window.removeEventListener(\"keydown\", keyDown);\n      window.removeEventListener(\"keyup\", keyUp);\n    };\n  }, [keyDown, keyUp]);\n\n  return keyPressed;\n}\n\nexport function useKeyPress(targetKeyCode: number, callback: () => void): void {\n  const keyPress = useCallback(\n    ({ keyCode }) => {\n      if (keyCode === targetKeyCode) {\n        callback();\n      }\n    },\n    [targetKeyCode, callback]\n  );\n\n  useEffect(() => {\n    window.addEventListener(\"keypress\", keyPress);\n    return () => {\n      window.removeEventListener(\"keypress\", keyPress);\n    };\n  }, [keyPress]);\n}\n\nexport type TouchPosition = { x: number, y: number} | undefined\n\nexport function useTouch(): TouchPosition {\n  const [touchDown, setTouchDown] = useState<boolean>(false);\n  const [touchPosition, setTouchPosition] = useState<TouchPosition>();\n\n  const handleMouseDown = useCallback((event: MouseEvent) => {\n    setTouchPosition({ x: event.clientX, y: event.clientY });\n    setTouchDown(true);\n  }, [setTouchPosition, setTouchDown]);\n\n  const handleMouseMove = useCallback((event: MouseEvent) => {\n    if (touchDown) setTouchPosition({ x: event.clientX, y: event.clientY });\n  }, [setTouchPosition, touchDown]);\n\n  const handleTouchStart = useCallback((event: TouchEvent) => {\n    setTouchPosition({ x: event.touches[0].clientX, y: event.touches[0].clientY });\n    setTouchDown(true);\n  }, [setTouchPosition, setTouchDown]);\n\n  const handleTouchMove = useCallback((event: TouchEvent) => {\n    if (touchDown) setTouchPosition({ x: event.touches[0].clientX, y: event.touches[0].clientY });\n  }, [setTouchPosition, touchDown]);\n\n  const handleTouchEnd = useCallback(() => {\n    setTouchPosition(undefined);\n    setTouchDown(false);\n  }, [setTouchPosition, setTouchDown]);\n\n  useEffect(() => {\n    window.addEventListener(\"touchstart\", handleTouchStart);\n    window.addEventListener(\"touchmove\", handleTouchMove);\n    window.addEventListener(\"touchend\", handleTouchEnd);\n    window.addEventListener(\"mousedown\", handleMouseDown);\n    window.addEventListener(\"mousemove\", handleMouseMove);\n    window.addEventListener(\"mouseup\", handleTouchEnd);\n    return () => {\n      window.removeEventListener(\"touchstart\", handleTouchStart);\n      window.removeEventListener(\"touchmove\", handleTouchMove);\n      window.removeEventListener(\"touchend\", handleTouchEnd);\n      window.removeEventListener(\"mousedown\", handleMouseDown);\n      window.removeEventListener(\"mousemove\", handleMouseMove);\n      window.removeEventListener(\"mouseup\", handleTouchEnd);\n    };\n  }, [handleTouchStart, handleTouchMove, handleTouchEnd, handleMouseDown, handleMouseMove]);\n\n  return touchPosition;\n}","import { Physics, useBox, useSphere } from \"@react-three/cannon\";\nimport {\n  AdaptiveDpr,\n  PerspectiveCamera,\n  RoundedBox,\n  softShadows,\n  Stars,\n  Stats,\n} from \"@react-three/drei\";\nimport { Canvas, useFrame, useThree } from \"@react-three/fiber\";\nimport {\n  EffectComposer,\n  Glitch,\n  Outline,\n  SMAA,\n  Vignette,\n} from \"@react-three/postprocessing\";\nimport { List, Map, Set } from \"immutable\";\nimport {\n  KEY_DOWN,\n  KEY_G,\n  KEY_LEFT,\n  KEY_RIGHT,\n  KEY_SPACE,\n  KEY_UP,\n} from \"keycode-js\";\nimport {\n  MutableRefObject,\n  Ref,\n  Suspense,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n} from \"react\";\nimport {\n  Camera,\n  Euler,\n  Event,\n  Group,\n  Matrix4,\n  Mesh,\n  Object3D,\n  Quaternion,\n  Vector2,\n  Vector3,\n} from \"three\";\nimport create, { State } from \"zustand\";\nimport \"./App.css\";\nimport { useKeyDown, useKeyPress, useTouch, TouchPosition } from \"./useInput\";\n\ntype Player = {\n  orientation: Quaternion;\n  color: string;\n};\n\nconst createPlayer = (): Player => ({\n  orientation: new Quaternion(),\n  color: getBallColor(Math.floor(Math.random() * ballColors.length)),\n});\n\nconst ballColors = [\n  \"rgb(249, 65, 68)\",\n  \"rgb(243, 114, 44)\",\n  \"rgb(248, 150, 30)\",\n  \"rgb(249, 199, 79)\",\n  \"rgb(144, 190, 109)\",\n  \"rgb(67, 170, 139)\",\n  \"rgb(87, 117, 144)\",\n];\n\nfunction getBallColor(ballId: number): string {\n  return ballColors[ballId % ballColors.length];\n}\n\ntype Ball = {\n  velocity: Vector3;\n  position: Vector3;\n  color: string;\n  ballId: number;\n};\n\nconst createBallFromPlayer = (ballId: number, player: Player): Ball => {\n  const translation = new Vector3(0, 0, 3);\n  const direction = new Vector3(0, 0, -1);\n\n  const position = translation.applyQuaternion(player.orientation);\n  const velocity = direction\n    .applyQuaternion(player.orientation)\n    .multiplyScalar(2);\n\n  return {\n    ballId,\n    position,\n    velocity,\n    color: player.color,\n  };\n};\n\ntype Brick = {\n  orbitOffset: Vector3;\n  color: string;\n  brickId: number;\n  mesh?: Mesh;\n};\n\nconst createBrick = (brickId: number, orbitOffset: Vector3): Brick => ({\n  brickId,\n  orbitOffset,\n  color: getBallColor(brickId),\n});\n\nconst getRandomBrickPosition = (): Vector3 => {\n  const brickWidth = 0.4;\n  const brickGap = 0.2;\n  const maxBricks = Math.floor((2 * Math.PI) / (brickWidth + brickGap));\n  const positionX = Math.floor(Math.random() * maxBricks);\n  const positionY = Math.floor(Math.random() * maxBricks);\n\n  return new Vector3(\n    positionX * (brickWidth + brickGap) + brickGap / 2,\n    positionY * (brickWidth + brickGap) + brickGap / 2,\n    1.5\n  );\n};\n\ntype Object3DRef = MutableRefObject<Object3D | undefined>;\ninterface AppState extends State {\n  player: Player;\n  balls: List<Ball>;\n  nextBallId: number;\n  bricks: Map<number, Brick>;\n  nextBrickId: number;\n  outlineSelection: Set<Object3DRef>;\n  actions: {\n    addBall: () => void;\n    removeBrick: (brickId: number) => void;\n    addBrick: (position: Vector3) => void;\n    addRandomBrick: () => void;\n    addDefaultBricks: () => void;\n    updateBrick: (brickId: number, changes: Partial<Brick>) => void;\n    movePlayer: (\n      delta: number,\n      leftPressed: boolean,\n      rightPressed: boolean,\n      upPressed: boolean,\n      downPressed: boolean,\n      touchPosition: TouchPosition\n    ) => void;\n    addOutlineSelection: (mesh: Object3DRef) => void;\n    removeOutlineSelection: (mesh: Object3DRef) => void;\n    resetGame: () => void;\n  };\n}\n\nconst useStore = create<AppState>((set, get) => ({\n  player: createPlayer(),\n  balls: List<Ball>(),\n  nextBallId: 0,\n  bricks: Map<number, Brick>(),\n  nextBrickId: 0,\n  outlineSelection: Set<Object3DRef>(),\n  actions: {\n    addBall: () =>\n      set((state) => {\n        const ball = createBallFromPlayer(state.nextBallId, state.player);\n        return {\n          balls: state.balls.push(ball).slice(-3),\n          nextBallId: state.nextBallId + 1,\n        };\n      }),\n    removeBrick: (brickId: number) =>\n      set((state) => ({ bricks: state.bricks.delete(brickId) })),\n    addRandomBrick: () => {\n      const {\n        actions: { addBrick },\n      } = get();\n      addBrick(getRandomBrickPosition());\n    },\n    addBrick: (position: Vector3) =>\n      set((state) => {\n        const brick = createBrick(state.nextBrickId, position);\n        return {\n          bricks: state.bricks.set(brick.brickId, brick),\n          nextBrickId: state.nextBrickId + 1,\n        };\n      }),\n    addDefaultBricks: () => {\n      const {\n        actions: { addBrick },\n      } = get();\n      set((state) => {\n        const points = generateFibonacciSphere();\n        points.forEach(addBrick);\n      });\n    },\n    updateBrick: (brickId: number, changes: Partial<Brick>) =>\n      set((state) => ({\n        bricks: state.bricks.update(brickId, (value) => ({\n          ...value,\n          ...changes,\n        })),\n      })),\n    movePlayer: (\n      delta: number,\n      leftPressed: boolean,\n      rightPressed: boolean,\n      upPressed: boolean,\n      downPressed: boolean,\n      touchPosition: TouchPosition\n    ) =>\n      set((state) => {\n        const [horizontalAngle, verticalAngle] = getAngleFromInput(\n          leftPressed,\n          rightPressed,\n          upPressed,\n          downPressed,\n          touchPosition\n        );\n        const verticalAxis = new Vector3(-1, 0, 0);\n        const verticalRotation = new Quaternion().setFromAxisAngle(\n          verticalAxis,\n          verticalAngle * delta\n        );\n        const horizontalAxis = new Vector3(0, 1, 0);\n        const horizontalRotation = new Quaternion().setFromAxisAngle(\n          horizontalAxis,\n          horizontalAngle * delta\n        );\n\n        const orientation = state.player.orientation\n          .clone()\n          .multiply(verticalRotation)\n          .multiply(horizontalRotation);\n\n        return {\n          player: {\n            ...state.player,\n            orientation,\n          },\n        };\n      }),\n    addOutlineSelection: (mesh: Object3DRef) =>\n      set((state) => ({ outlineSelection: state.outlineSelection.add(mesh) })),\n    removeOutlineSelection: (mesh: Object3DRef) =>\n      set((state) => ({\n        outlineSelection: state.outlineSelection.remove(mesh),\n      })),\n    resetGame: () => {\n      const {\n        actions: { addDefaultBricks },\n      } = get();\n      addDefaultBricks();\n    },\n  },\n}));\n\nfunction generateFibonacciSphere() {\n  const samples = 64;\n  const radius = 1.5;\n\n  const points = [];\n  const offset = 2 / samples;\n  const increment = Math.PI * (3 - Math.sqrt(5));\n\n  for (let i = 0; i < samples; i++) {\n    const y = i * offset - 1 + offset / 2;\n    const distance = Math.sqrt(1 - Math.pow(y, 2));\n    const phi = ((i + 1) % samples) * increment;\n    const x = Math.cos(phi) * distance;\n    const z = Math.sin(phi) * distance;\n    points.push(new Vector3(x * radius, y * radius, z * radius));\n  }\n\n  return points;\n}\n\nfunction getAngleFromInput(\n  leftPressed: boolean,\n  rightPressed: boolean,\n  upPressed: boolean,\n  downPressed: boolean,\n  touchPosition: TouchPosition\n): [number, number] {\n  if (touchPosition) {\n    const verticalAngle =\n      ((window.innerHeight - touchPosition.y) / window.innerHeight - 0.5) * 2;\n    const horizontalAngle = (touchPosition.x / window.innerWidth - 0.5) * 2;\n    return [horizontalAngle, verticalAngle];\n  }\n  const verticalAngle = downPressed ? -1 : upPressed ? 1 : 0;\n  const horizontalAngle = leftPressed ? -1 : rightPressed ? 1 : 0;\n  return [horizontalAngle, verticalAngle];\n}\n\nfunction lookAt(eye: Vector3, target: Vector3): [Euler, Vector3] {\n  const up = new Vector3(0, 1, 0);\n  const lookAt = new Matrix4().lookAt(eye, target, up);\n  const rotation = new Euler().setFromRotationMatrix(lookAt);\n\n  return [rotation, eye];\n}\n\nfunction PlayerGroup() {\n  const addOutlineSelection = useStore(\n    (state) => state.actions.addOutlineSelection\n  );\n  const removeOutlineSelection = useStore(\n    (state) => state.actions.removeOutlineSelection\n  );\n  const leftPressed = useKeyDown(KEY_LEFT);\n  const rightPressed = useKeyDown(KEY_RIGHT);\n  const upPressed = useKeyDown(KEY_UP);\n  const downPressed = useKeyDown(KEY_DOWN);\n  const touchPosition = useTouch();\n  const padGroup = useRef<Group>(null!);\n  const camera = useRef<Camera>(null!);\n  const player = useStore((state) => state.player);\n  const movePlayer = useStore((state) => state.actions.movePlayer);\n  const addBall = useStore((state) => state.actions.addBall);\n  const padSize: [number, number, number] = [1, 0.2, 0.1];\n  const translation = new Vector3(0, 0, 4);\n\n  const [ref, api] = useBox(() => ({\n    args: padSize,\n    mass: 1,\n    position: translation.toArray(),\n    rotation: [Math.PI, 0, 0],\n    type: \"Static\",\n    onCollide: collide,\n  }));\n\n  const collide = useCallback((e: Event) => {}, []);\n\n  useKeyPress(KEY_SPACE, addBall);\n\n  useFrame((state, delta) => {\n    movePlayer(\n      delta,\n      leftPressed,\n      rightPressed,\n      upPressed,\n      downPressed,\n      touchPosition\n    );\n\n    const rotation = new Euler().setFromQuaternion(player.orientation);\n    const position = translation.clone().applyQuaternion(player.orientation);\n\n    api.rotation.copy(rotation);\n    api.position.copy(position);\n  });\n\n  useEffect(() => {\n    const mesh = ref.current!;\n    mesh.addEventListener(\"collide\", collide);\n    return () => mesh.removeEventListener(\"collide\", collide);\n  }, [ref, collide]);\n\n  useEffect(() => {\n    addOutlineSelection(ref);\n    return () => removeOutlineSelection(ref);\n  }, [ref, addOutlineSelection, removeOutlineSelection]);\n\n  return (\n    <group ref={padGroup} position={[0, 0, 0]}>\n      <RoundedBox\n        args={padSize} // Width, Height and Depth of the box\n        radius={0.05} // Border-Radius of the box\n        ref={ref as Ref<Mesh>} // All THREE.Mesh props are valid\n        onClick={addBall}\n        receiveShadow\n      >\n        <meshToonMaterial attach=\"material\" color=\"#f3f3f3\" />\n        <PerspectiveCamera\n          makeDefault\n          ref={camera}\n          position={[0, 1, 2]}\n          rotation={[-Math.PI / 16, 0, 0]}\n        />\n      </RoundedBox>\n    </group>\n  );\n}\n\nfunction BallGroup(props: JSX.IntrinsicElements[\"group\"]) {\n  const balls = useStore((state) => state.balls);\n\n  return (\n    <group {...props}>\n      {balls.map((ball) => (\n        <BallMesh key={ball.ballId} ball={ball} />\n      ))}\n    </group>\n  );\n}\n\nfunction BallMesh({ ball }: { ball: Ball }) {\n  const addOutlineSelection = useStore(\n    (state) => state.actions.addOutlineSelection\n  );\n  const removeOutlineSelection = useStore(\n    (state) => state.actions.removeOutlineSelection\n  );\n  const ballRadius = 0.2;\n\n  const [ref] = useSphere(() => ({\n    args: ballRadius,\n    mass: 1,\n    position: ball.position.toArray(),\n    velocity: ball.velocity.toArray(),\n  }));\n\n  useEffect(() => {\n    addOutlineSelection(ref);\n    return () => removeOutlineSelection(ref);\n  }, [ref, addOutlineSelection, removeOutlineSelection]);\n\n  return (\n    <mesh ref={ref} scale={ballRadius} castShadow>\n      <sphereGeometry args={[1, 16, 16]} />\n      <meshToonMaterial attach=\"material\" color={ball.color} />\n    </mesh>\n  );\n}\n\nfunction BrickGroup() {\n  const bricks = useStore((state) => state.bricks);\n\n  return (\n    <group>\n      {bricks.valueSeq().map((brick: Brick) => (\n        <BrickMesh key={brick.brickId} brick={brick} />\n      ))}\n    </group>\n  );\n}\n\nfunction BrickMesh({ brick }: { brick: Brick }) {\n  const playerColor = useStore((state) => state.player.color);\n  const updateBrick = useStore((state) => state.actions.updateBrick);\n  const addOutlineSelection = useStore(\n    (state) => state.actions.addOutlineSelection\n  );\n  const removeOutlineSelection = useStore(\n    (state) => state.actions.removeOutlineSelection\n  );\n  const [rotation, position] = useMemo(\n    () => lookAt(brick.orbitOffset, new Vector3()),\n    [brick]\n  );\n  const brickSize: [number, number, number] = [0.4, 0.4, 0.1];\n  const [ref] = useBox(\n    () => ({\n      args: brickSize,\n      mass: 1,\n      position: position.toArray(),\n      rotation: rotation.toArray(),\n      type: \"Static\",\n      onCollide: collide,\n    }),\n    undefined,\n    [rotation, position]\n  );\n\n  const collide = useCallback(\n    (e: Event) => {\n      updateBrick(brick.brickId, { color: playerColor });\n    },\n    [updateBrick, brick, playerColor]\n  );\n\n  useEffect(() => {\n    addOutlineSelection(ref);\n    return () => removeOutlineSelection(ref);\n  }, [ref, addOutlineSelection, removeOutlineSelection]);\n\n  return (\n    <RoundedBox\n      args={brickSize} // Width, Height and Depth of the box\n      radius={0.05} // Border-Radius of the box\n      ref={ref as Ref<Mesh>} // All THREE.Mesh props are valid\n      receiveShadow\n    >\n      <meshToonMaterial attach=\"material\" color={brick.color} />\n    </RoundedBox>\n  );\n}\n\nfunction Effects() {\n  const outlineSelection = useStore((state) => state.outlineSelection);\n  const outlineSelectionArray = useMemo(\n    () =>\n      outlineSelection\n        .toArray()\n        .filter(\n          (v: Object3DRef): v is MutableRefObject<Object3D> =>\n            v.current !== undefined\n        ),\n    [outlineSelection]\n  );\n  const gPressed = useKeyDown(KEY_G);\n\n  return (\n    <Suspense fallback={null}>\n      <EffectComposer multisampling={0} autoClear={false}>\n        {gPressed ? (\n          <Glitch\n            active={true} // turn on/off the effect (switches between \"mode\" prop and GlitchMode.DISABLED)\n            ratio={0.85} // Threshold for strong glitches, 0 - no weak glitches, 1 - no strong glitches.\n            delay={new Vector2(0, 0)}\n          />\n        ) : (\n          <SMAA />\n        )}\n        <Outline\n          selection={outlineSelectionArray}\n          edgeStrength={10} // the edge strength\n          pulseSpeed={0.0} // a pulse speed. A value of zero disables the pulse effect\n          visibleEdgeColor={0xffffff} // the color of visible edges\n          hiddenEdgeColor={0x22090a} // the color of hidden edges\n          blur={false} // whether the outline should be blurred\n          xRay={false} // indicates whether X-Ray outlines are enabled\n          width={2048}\n          height={2048}\n        />\n        <Stars\n          radius={100} // Radius of the inner sphere (default=100)\n          depth={50} // Depth of area where stars should fit (default=50)\n          count={5000} // Amount of stars (default=5000)\n          factor={4} // Size factor (default=4)\n          saturation={0} // Saturation 0-1 (default=0)\n          fade // Faded dots (default=false)\n        />\n        <Vignette eskil={false} offset={0.1} darkness={1.1} />\n        {/* <SMAA /> */}\n      </EffectComposer>\n    </Suspense>\n  );\n}\n// colored bricks all around the sphere\n// color combination to build\n// special bricks to add new colors to other players\n// special brick to shuffle players\n// color bricks (splatoon style)\n\nfunction ViewportResize() {\n  const { gl, viewport } = useThree();\n  const targetSize = new Vector2(1024, 1024 / viewport.aspect);\n\n  useFrame(() => {\n    const size = gl.getDrawingBufferSize(new Vector2());\n    if (!size.equals(targetSize)) {\n      gl.setDrawingBufferSize(targetSize.x, targetSize.y, 1);\n    }\n  });\n\n  return null;\n}\n\nsoftShadows({\n  frustum: 3.75, // Frustum width (default: 3.75) must be a float\n  size: 0.005, // World size (default: 0.005) must be a float\n  near: 9.5, // Near plane (default: 9.5) must be a float\n  samples: 17, // Samples (default: 17) must be a int\n  rings: 11, // Rings (default: 11) must be a int\n});\n\nexport default function App() {\n  const resetGame = useStore((state) => state.actions.resetGame);\n  useEffect(resetGame, [resetGame]);\n\n  return (\n    <Canvas style={{ backgroundColor: \"#121212\" }} shadows>\n      <ViewportResize />\n      <Stats\n        showPanel={0} // Start-up panel (default=0)\n        className=\"stats\" // Optional className to add to the stats container dom element\n      />\n      <AdaptiveDpr pixelated />\n      <Physics\n        gravity={[0, 0, 0]}\n        defaultContactMaterial={{\n          friction: 0,\n          restitution: 1.1,\n        }}\n      >\n        <pointLight\n          position={[30, 10, 10]}\n          castShadow\n          shadow-mapSize-width={256}\n          shadow-mapSize-height={256}\n        />\n        <BallGroup />\n        <BrickGroup />\n        <PlayerGroup />\n      </Physics>\n      <Effects />\n    </Canvas>\n  );\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"bootstrap/dist/css/bootstrap.css\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}